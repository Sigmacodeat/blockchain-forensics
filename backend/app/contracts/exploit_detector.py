"""
Exploit Pattern Recognition
============================
Erkennt bekannte Exploit-Muster aus realen Angriffen:
- DAO Hack (Reentrancy)
- Parity Wallet Hack
- Flash Loan Attacks
- Price Oracle Manipulation
- Rugpull Patterns
- Honeypot Contracts
"""

from typing import List, Optional
from dataclasses import dataclass
from enum import Enum


class ExploitCategory(str, Enum):
    """Kategorien von Exploits"""
    REENTRANCY = "reentrancy"
    FLASH_LOAN = "flash_loan_attack"
    ORACLE_MANIPULATION = "oracle_manipulation"
    RUGPULL = "rugpull"
    HONEYPOT = "honeypot"
    ACCESS_CONTROL = "access_control_exploit"
    INTEGER_OVERFLOW = "integer_overflow_exploit"
    LOGIC_BUG = "logic_bug_exploit"
    GOVERNANCE_ATTACK = "governance_attack"
    FRONT_RUNNING = "front_running"


@dataclass
class ExploitSignature:
    """Signatur eines bekannten Exploits"""
    name: str
    category: ExploitCategory
    bytecode_pattern: Optional[str]
    opcode_sequence: Optional[List[str]]
    description: str
    real_world_example: Optional[str]
    cve_id: Optional[str]
    detected_in: List[str]  # Liste von Contract Addresses wo gesehen


@dataclass
class ExploitDetection:
    """Erkannter Exploit"""
    exploit_name: str
    category: ExploitCategory
    confidence: float
    severity: str
    description: str
    indicators: List[str]
    mitigation: str
    real_world_cases: List[str]


# Bekannte Exploit-Signaturen (aus realen Hacks)
KNOWN_EXPLOITS = [
    ExploitSignature(
        name="DAO_Reentrancy",
        category=ExploitCategory.REENTRANCY,
        bytecode_pattern=None,
        opcode_sequence=['CALL', 'SSTORE'],
        description="Classic DAO hack reentrancy pattern",
        real_world_example="The DAO Hack 2016 - $60M stolen",
        cve_id=None,
        detected_in=["0xbb9bc244d798123fde783fcc1c72d3bb8c189413"],
    ),
    
    ExploitSignature(
        name="Parity_Wallet_Selfdestruct",
        category=ExploitCategory.ACCESS_CONTROL,
        bytecode_pattern="ff",  # SELFDESTRUCT opcode
        opcode_sequence=['DELEGATECALL', 'SELFDESTRUCT'],
        description="Parity Multi-Sig Wallet vulnerability - unprotected selfdestruct",
        real_world_example="Parity Wallet Hack 2017 - $300M frozen",
        cve_id=None,
        detected_in=["0x863df6bfa4469f3ead0be8f9f2aae51c91a907b4"],
    ),
    
    ExploitSignature(
        name="Flash_Loan_Price_Manipulation",
        category=ExploitCategory.FLASH_LOAN,
        bytecode_pattern=None,
        opcode_sequence=['CALL', 'BALANCE', 'DIV'],  # Price calculation based on balance
        description="Flash loan attack pattern - manipulate price oracle via large loan",
        real_world_example="bZx Attack 2020 - $954K stolen",
        cve_id=None,
        detected_in=[],
    ),
    
    ExploitSignature(
        name="Honeypot_Transfer_Trap",
        category=ExploitCategory.HONEYPOT,
        bytecode_pattern=None,
        opcode_sequence=['CALLER', 'ORIGIN', 'EQ', 'JUMPI'],
        description="Honeypot contract that blocks transfers unless called directly",
        real_world_example="Various honeypot scams",
        cve_id=None,
        detected_in=[],
    ),
    
    ExploitSignature(
        name="Rugpull_Ownership_Backdoor",
        category=ExploitCategory.RUGPULL,
        bytecode_pattern=None,
        opcode_sequence=['CALLER', 'SLOAD', 'EQ'],  # Owner check before SELFDESTRUCT
        description="Hidden ownership functions that allow draining funds",
        real_world_example="Squid Game Token Rugpull 2021 - $3.3M",
        cve_id=None,
        detected_in=[],
    ),
]


# Pattern-spezifische Detektoren
class PatternDetectors:
    """Spezialisierte Detektoren für verschiedene Exploit-Kategorien"""
    
    @staticmethod
    def detect_flash_loan_pattern(opcodes: List[tuple]) -> Optional[ExploitDetection]:
        """
        Erkennt Flash Loan Attack Pattern
        
        Indicators:
        - Borrow within single transaction
        - Price calculation based on balance
        - Immediate repayment
        """
        opcode_names = [op[1] for op in opcodes]
        
        # Look for balance-based price oracle pattern
        has_balance_calc = False
        for i in range(len(opcodes) - 2):
            if (opcode_names[i] == 'BALANCE' and 
                opcode_names[i+1] in ['DIV', 'MUL']):
                has_balance_calc = True
                break
        
        # Look for flash loan-like pattern (borrow + repay in single tx)
        has_call_sequence = False
        call_count = opcode_names.count('CALL')
        if call_count >= 3:  # Multiple calls suggest borrow-use-repay
            has_call_sequence = True
        
        if has_balance_calc and has_call_sequence:
            return ExploitDetection(
                exploit_name="Flash Loan Vulnerability",
                category=ExploitCategory.FLASH_LOAN,
                confidence=0.65,
                severity="high",
                description=(
                    "Contract appears vulnerable to flash loan attacks. "
                    "Price calculations based on token balance can be manipulated "
                    "via large flash loans."
                ),
                indicators=[
                    "Balance-based price oracle detected",
                    "Multiple external calls in sequence",
                ],
                mitigation=(
                    "Use time-weighted average price (TWAP) oracles like Chainlink. "
                    "Avoid using spot balance for critical calculations."
                ),
                real_world_cases=[
                    "bZx (2020): $954K",
                    "Harvest Finance (2020): $34M",
                    "Cream Finance (2021): $130M",
                ],
            )
        
        return None
    
    @staticmethod
    def detect_honeypot_pattern(opcodes: List[tuple]) -> Optional[ExploitDetection]:
        """
        Erkennt Honeypot Contract Pattern
        
        Indicators:
        - tx.origin checks (blocks calls from contracts)
        - Hidden transfer restrictions
        - Owner-only successful transfers
        """
        opcode_names = [op[1] for op in opcodes]
        
        indicators = []
        
        # Check for ORIGIN usage (red flag for honeypots)
        if 'ORIGIN' in opcode_names:
            origin_count = opcode_names.count('ORIGIN')
            if origin_count > 1:
                indicators.append(f"Multiple tx.origin checks ({origin_count})")
        
        # Check for complex conditional logic around transfers
        # Pattern: CALLER -> EQ -> JUMPI (different behavior for owner)
        has_owner_bypass = False
        for i in range(len(opcodes) - 3):
            if (opcode_names[i] == 'CALLER' and
                opcode_names[i+1] == 'EQ' and
                opcode_names[i+2] == 'JUMPI'):
                has_owner_bypass = True
                indicators.append("Owner bypass logic detected")
                break
        
        # Check for hidden modifiers
        jumpi_count = opcode_names.count('JUMPI')
        if jumpi_count > 10:  # Many conditional jumps = complex hidden logic
            indicators.append(f"High conditional complexity ({jumpi_count} JUMPI)")
        
        if len(indicators) >= 2:
            return ExploitDetection(
                exploit_name="Potential Honeypot Contract",
                category=ExploitCategory.HONEYPOT,
                confidence=0.7,
                severity="high",
                description=(
                    "Contract exhibits honeypot characteristics. "
                    "May allow buys but block sells, or have hidden transfer restrictions."
                ),
                indicators=indicators,
                mitigation=(
                    "DO NOT INVEST. This contract likely prevents you from selling tokens. "
                    "Common in token scams."
                ),
                real_world_cases=[
                    "Numerous ERC20 honeypot tokens",
                    "Fake DeFi projects",
                ],
            )
        
        return None
    
    @staticmethod
    def detect_rugpull_pattern(opcodes: List[tuple]) -> Optional[ExploitDetection]:
        """
        Erkennt Rugpull-Risiko
        
        Indicators:
        - Mint function controlled by owner
        - Ownership transfer capability
        - Pause/unpause functions
        - Lack of timelock
        """
        opcode_names = [op[1] for op in opcodes]
        
        indicators = []
        risk_score = 0.0
        
        # Check for SELFDESTRUCT (ultimate rugpull)
        if 'SELFDESTRUCT' in opcode_names:
            indicators.append("SELFDESTRUCT capability (can destroy contract)")
            risk_score += 0.4
        
        # Check for unrestricted DELEGATECALL (can drain funds)
        if 'DELEGATECALL' in opcode_names:
            delegatecall_count = opcode_names.count('DELEGATECALL')
            indicators.append(f"DELEGATECALL present ({delegatecall_count}x) - can modify state")
            risk_score += 0.3
        
        # High number of owner-gated functions
        # Pattern: CALLER -> SLOAD (owner) -> EQ -> JUMPI
        owner_checks = 0
        for i in range(len(opcodes) - 3):
            if (opcode_names[i] == 'CALLER' and
                opcode_names[i+1] == 'SLOAD' and
                opcode_names[i+2] == 'EQ'):
                owner_checks += 1
        
        if owner_checks > 3:
            indicators.append(f"Multiple owner-restricted functions ({owner_checks})")
            risk_score += 0.2
        
        # Check for pausable pattern
        # SLOAD -> ISZERO -> JUMPI (paused state check)
        pause_pattern_count = 0
        for i in range(len(opcodes) - 2):
            if (opcode_names[i] == 'SLOAD' and
                opcode_names[i+1] == 'ISZERO' and
                opcode_names[i+2] == 'JUMPI'):
                pause_pattern_count += 1
        
        if pause_pattern_count > 0:
            indicators.append("Pausable functionality detected")
            risk_score += 0.1
        
        if risk_score >= 0.4:
            return ExploitDetection(
                exploit_name="Rugpull Risk",
                category=ExploitCategory.RUGPULL,
                confidence=min(risk_score, 0.95),
                severity="critical" if risk_score > 0.7 else "high",
                description=(
                    "Contract has characteristics commonly seen in rugpull scams. "
                    "Owner has excessive control over contract functionality and funds."
                ),
                indicators=indicators,
                mitigation=(
                    "EXTREME CAUTION. Verify:\n"
                    "1. Ownership is renounced or timelock-protected\n"
                    "2. No hidden mint/burn functions\n"
                    "3. Liquidity is locked\n"
                    "4. Contract is audited by reputable firm"
                ),
                real_world_cases=[
                    "Squid Game Token (2021): $3.3M",
                    "Uranium Finance (2021): $50M",
                    "Meerkat Finance (2021): $31M",
                ],
            )
        
        return None
    
    @staticmethod
    def detect_oracle_manipulation(opcodes: List[tuple]) -> Optional[ExploitDetection]:
        """
        Erkennt Oracle Manipulation Anfälligkeit
        
        Indicators:
        - Single-source price data
        - Spot price usage
        - Missing TWAP
        """
        opcode_names = [op[1] for op in opcodes]
        
        indicators = []
        
        # Check for balance-based pricing (vulnerable to manipulation)
        if 'BALANCE' in opcode_names:
            # Look for BALANCE -> DIV pattern (price = reserve / supply)
            for i in range(len(opcodes) - 1):
                if opcode_names[i] == 'BALANCE' and opcode_names[i+1] in ['DIV', 'MUL']:
                    indicators.append("Spot balance used in calculation")
                    break
        
        # Missing time-weighted logic (no TIMESTAMP averaging)
        has_timestamp = 'TIMESTAMP' in opcode_names
        has_storage_array = opcode_names.count('SLOAD') > 5  # Multiple storage slots
        
        if not (has_timestamp and has_storage_array):
            indicators.append("No time-weighted averaging detected")
        
        if len(indicators) > 0:
            return ExploitDetection(
                exploit_name="Oracle Manipulation Risk",
                category=ExploitCategory.ORACLE_MANIPULATION,
                confidence=0.6,
                severity="high",
                description=(
                    "Contract may be vulnerable to price oracle manipulation. "
                    "Uses spot prices instead of time-weighted averages."
                ),
                indicators=indicators,
                mitigation=(
                    "Use Chainlink Price Feeds or implement TWAP (Time-Weighted Average Price). "
                    "Never rely on spot balances for critical price data."
                ),
                real_world_cases=[
                    "Harvest Finance (2020): $34M via flash loan + oracle manipulation",
                ],
            )
        
        return None


class ExploitDetector:
    """
    Main Exploit Detection Engine
    Kombiniert alle Pattern-Detektoren
    """
    
    def __init__(self):
        self.known_exploits = KNOWN_EXPLOITS
        self.pattern_detectors = PatternDetectors()
    
    def detect_exploits(self, bytecode: str, opcodes: List[tuple]) -> List[ExploitDetection]:
        """
        Führt alle Exploit-Erkennungen durch
        
        Returns:
            Liste aller erkannten Exploits
        """
        detections: List[ExploitDetection] = []
        
        # 1. Flash Loan Pattern
        flash_loan = self.pattern_detectors.detect_flash_loan_pattern(opcodes)
        if flash_loan:
            detections.append(flash_loan)
        
        # 2. Honeypot Pattern
        honeypot = self.pattern_detectors.detect_honeypot_pattern(opcodes)
        if honeypot:
            detections.append(honeypot)
        
        # 3. Rugpull Pattern
        rugpull = self.pattern_detectors.detect_rugpull_pattern(opcodes)
        if rugpull:
            detections.append(rugpull)
        
        # 4. Oracle Manipulation
        oracle = self.pattern_detectors.detect_oracle_manipulation(opcodes)
        if oracle:
            detections.append(oracle)
        
        # 5. Known Exploit Signatures
        signature_matches = self._match_known_signatures(bytecode, opcodes)
        detections.extend(signature_matches)
        
        return detections
    
    def _match_known_signatures(self, bytecode: str, opcodes: List[tuple]) -> List[ExploitDetection]:
        """Matched gegen bekannte Exploit-Signaturen"""
        matches = []
        opcode_names = [op[1] for op in opcodes]
        
        for sig in self.known_exploits:
            matched = False
            
            # Check bytecode pattern
            if sig.bytecode_pattern and sig.bytecode_pattern in bytecode:
                matched = True
            
            # Check opcode sequence
            if sig.opcode_sequence:
                seq_len = len(sig.opcode_sequence)
                for i in range(len(opcode_names) - seq_len + 1):
                    if opcode_names[i:i+seq_len] == sig.opcode_sequence:
                        matched = True
                        break
            
            if matched:
                matches.append(ExploitDetection(
                    exploit_name=sig.name,
                    category=sig.category,
                    confidence=0.9,
                    severity="critical",
                    description=sig.description,
                    indicators=[f"Matched known exploit: {sig.name}"],
                    mitigation=f"This matches the pattern of {sig.real_world_example}",
                    real_world_cases=[sig.real_world_example] if sig.real_world_example else [],
                ))
        
        return matches


# Singleton
exploit_detector = ExploitDetector()
