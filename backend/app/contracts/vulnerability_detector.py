"""
Smart Contract Vulnerability Detection
=======================================
Erkennt bekannte Schwachstellen in Smart Contracts:
- Reentrancy
- Integer Overflow/Underflow
- Unchecked External Calls
- Access Control Issues
- Logic Bugs
- Gas Optimization Issues

Basiert auf OWASP Smart Contract Top 10 und bekannten Exploits
"""

from typing import Dict, List, Optional, Set
from dataclasses import dataclass
from enum import Enum


class VulnerabilitySeverity(str, Enum):
    """Schweregrad von Vulnerabilities"""
    CRITICAL = "critical"  # Sofortiger Geldverlust möglich
    HIGH = "high"  # Hoher Schaden wahrscheinlich
    MEDIUM = "medium"  # Moderater Schaden möglich
    LOW = "low"  # Geringe Auswirkungen
    INFO = "info"  # Informational


class VulnerabilityType(str, Enum):
    """Kategorien von Vulnerabilities"""
    REENTRANCY = "reentrancy"
    INTEGER_OVERFLOW = "integer_overflow"
    UNCHECKED_CALL = "unchecked_external_call"
    ACCESS_CONTROL = "access_control"
    DELEGATECALL = "delegatecall_injection"
    TIMESTAMP_DEPENDENCE = "timestamp_dependence"
    TX_ORIGIN = "tx_origin_authentication"
    SELFDESTRUCT = "unprotected_selfdestruct"
    UNINITIALIZED_STORAGE = "uninitialized_storage"
    FRONTRUNNING = "frontrunning"
    LOGIC_ERROR = "logic_error"
    GAS_LIMIT = "gas_limit_dos"


@dataclass
class Vulnerability:
    """Einzelne Vulnerability"""
    vuln_type: VulnerabilityType
    severity: VulnerabilitySeverity
    title: str
    description: str
    location: str  # Offset oder Function
    confidence: float  # 0.0 - 1.0
    remediation: str
    references: List[str]
    cwe_id: Optional[str] = None  # Common Weakness Enumeration ID


@dataclass
class VulnerabilityReport:
    """Vollständiger Vulnerability Report"""
    contract_address: Optional[str]
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    vulnerabilities: List[Vulnerability]
    overall_risk: str  # "critical", "high", "medium", "low"


class VulnerabilityDetector:
    """
    Vulnerability Detection Engine
    Kombiniert statische Analyse mit Pattern-Matching
    """
    
    def __init__(self):
        self.known_vulnerable_patterns: Dict[str, List] = self._load_patterns()
    
    def detect(
        self, 
        bytecode: str,
        opcodes: List[tuple],
        source_code: Optional[str] = None
    ) -> VulnerabilityReport:
        """
        Führt vollständige Vulnerability-Analyse durch
        
        Args:
            bytecode: Contract bytecode (hex)
            opcodes: Disassembled opcodes from bytecode_analyzer
            source_code: Optional Solidity source code
        
        Returns:
            VulnerabilityReport mit allen gefundenen Schwachstellen
        """
        vulnerabilities: List[Vulnerability] = []
        
        # 1. Reentrancy Detection
        vulnerabilities.extend(self._detect_reentrancy(opcodes))
        
        # 2. Integer Overflow/Underflow (pre-Solidity 0.8.0)
        vulnerabilities.extend(self._detect_integer_issues(opcodes))
        
        # 3. Unchecked External Calls
        vulnerabilities.extend(self._detect_unchecked_calls(opcodes))
        
        # 4. Access Control Issues
        vulnerabilities.extend(self._detect_access_control(opcodes))
        
        # 5. Delegatecall Injection
        vulnerabilities.extend(self._detect_delegatecall_issues(opcodes))
        
        # 6. Timestamp Dependence
        vulnerabilities.extend(self._detect_timestamp_issues(opcodes))
        
        # 7. tx.origin Authentication
        vulnerabilities.extend(self._detect_tx_origin(opcodes))
        
        # 8. Unprotected Selfdestruct
        vulnerabilities.extend(self._detect_selfdestruct_issues(opcodes))
        
        # 9. Frontrunning Risks
        vulnerabilities.extend(self._detect_frontrunning(opcodes))
        
        # 10. Gas Limit DoS
        vulnerabilities.extend(self._detect_gas_issues(opcodes))
        
        # Count by severity
        counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
        }
        
        for vuln in vulnerabilities:
            if vuln.severity.value in counts:
                counts[vuln.severity.value] += 1
        
        # Overall risk assessment
        if counts["critical"] > 0:
            overall_risk = "critical"
        elif counts["high"] > 0:
            overall_risk = "high"
        elif counts["medium"] > 0:
            overall_risk = "medium"
        else:
            overall_risk = "low"
        
        return VulnerabilityReport(
            contract_address=None,
            total_vulnerabilities=len(vulnerabilities),
            critical_count=counts["critical"],
            high_count=counts["high"],
            medium_count=counts["medium"],
            low_count=counts["low"],
            vulnerabilities=vulnerabilities,
            overall_risk=overall_risk,
        )
    
    def _detect_reentrancy(self, opcodes: List[tuple]) -> List[Vulnerability]:
        """
        Erkennt Reentrancy-Vulnerabilities
        Pattern: External call (CALL/DELEGATECALL) vor State-Change (SSTORE)
        """
        vulns = []
        opcode_names = [op[1] for op in opcodes]
        
        # Check for CALL -> SSTORE pattern
        for i in range(len(opcodes) - 1):
            if opcode_names[i] in ['CALL', 'DELEGATECALL', 'CALLCODE']:
                # Scan next 20 opcodes for SSTORE
                for j in range(i+1, min(i+20, len(opcodes))):
                    if opcode_names[j] == 'SSTORE':
                        # Potential reentrancy: external call before state change
                        vulns.append(Vulnerability(
                            vuln_type=VulnerabilityType.REENTRANCY,
                            severity=VulnerabilitySeverity.CRITICAL,
                            title="Potential Reentrancy Vulnerability",
                            description=(
                                f"External call at offset {opcodes[i][0]} followed by "
                                f"state change (SSTORE) at offset {opcodes[j][0]}. "
                                "This allows reentrancy attacks where the called contract "
                                "can call back before state is updated."
                            ),
                            location=f"offset_{opcodes[i][0]}",
                            confidence=0.75,
                            remediation=(
                                "Use Checks-Effects-Interactions pattern: "
                                "1. Check conditions, 2. Update state, 3. External calls. "
                                "Or use ReentrancyGuard modifier."
                            ),
                            references=[
                                "https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/",
                                "CWE-841"
                            ],
                            cwe_id="CWE-841",
                        ))
                        break  # Only report once per CALL
        
        return vulns
    
    def _detect_integer_issues(self, opcodes: List[tuple]) -> List[Vulnerability]:
        """
        Erkennt potenzielle Integer Overflow/Underflow
        (Relevant für Solidity < 0.8.0)
        """
        vulns = []
        opcode_names = [op[1] for op in opcodes]
        
        # Check for unchecked arithmetic
        arithmetic_ops = ['ADD', 'MUL', 'SUB', 'EXP']
        
        for i, (offset, opcode, _) in enumerate(opcodes):
            if opcode in arithmetic_ops:
                # Check if there's overflow check nearby (ISZERO, REVERT pattern)
                has_check = False
                for j in range(max(0, i-5), min(i+5, len(opcodes))):
                    if opcode_names[j] in ['ISZERO', 'REVERT', 'REQUIRE']:
                        has_check = True
                        break
                
                if not has_check and i % 10 == 0:  # Report sparsely to avoid spam
                    vulns.append(Vulnerability(
                        vuln_type=VulnerabilityType.INTEGER_OVERFLOW,
                        severity=VulnerabilitySeverity.MEDIUM,
                        title="Potential Integer Overflow/Underflow",
                        description=(
                            f"Arithmetic operation {opcode} at offset {offset} "
                            "without visible overflow check. If using Solidity < 0.8.0, "
                            "this may be vulnerable to integer overflow/underflow."
                        ),
                        location=f"offset_{offset}",
                        confidence=0.5,  # Low confidence without source code
                        remediation=(
                            "Use Solidity 0.8.0+ with built-in overflow checks, "
                            "or use SafeMath library for older versions."
                        ),
                        references=[
                            "https://consensys.github.io/smart-contract-best-practices/attacks/insecure-arithmetic/",
                            "CWE-190"
                        ],
                        cwe_id="CWE-190",
                    ))
        
        return vulns
    
    def _detect_unchecked_calls(self, opcodes: List[tuple]) -> List[Vulnerability]:
        """Erkennt externe Calls ohne Return-Value-Check"""
        vulns = []
        opcode_names = [op[1] for op in opcodes]
        
        for i, (offset, opcode, _) in enumerate(opcodes):
            if opcode in ['CALL', 'CALLCODE', 'STATICCALL']:
                # CALL returns success (1) or failure (0) on stack
                # Check if next opcodes check the return value
                has_check = False
                for j in range(i+1, min(i+5, len(opcodes))):
                    if opcode_names[j] in ['ISZERO', 'JUMPI', 'REVERT']:
                        has_check = True
                        break
                    elif opcode_names[j] == 'POP':
                        # Return value popped without check
                        break
                
                if not has_check:
                    vulns.append(Vulnerability(
                        vuln_type=VulnerabilityType.UNCHECKED_CALL,
                        severity=VulnerabilitySeverity.MEDIUM,
                        title="Unchecked External Call",
                        description=(
                            f"External call at offset {offset} does not check return value. "
                            "Failed calls may go unnoticed, leading to unexpected behavior."
                        ),
                        location=f"offset_{offset}",
                        confidence=0.7,
                        remediation=(
                            "Always check return values of external calls:\n"
                            "(bool success, ) = target.call(...);\n"
                            "require(success, 'Call failed');"
                        ),
                        references=[
                            "https://swcregistry.io/docs/SWC-104",
                            "CWE-252"
                        ],
                        cwe_id="CWE-252",
                    ))
        
        return vulns
    
    def _detect_access_control(self, opcodes: List[tuple]) -> List[Vulnerability]:
        """Erkennt fehlende Access Control Checks"""
        vulns = []
        opcode_names = [op[1] for op in opcodes]
        
        # Check for SELFDESTRUCT or DELEGATECALL without CALLER check
        dangerous_ops = {
            'SELFDESTRUCT': VulnerabilitySeverity.CRITICAL,
            'DELEGATECALL': VulnerabilitySeverity.HIGH,
        }
        
        for i, (offset, opcode, _) in enumerate(opcodes):
            if opcode in dangerous_ops:
                # Look backwards for CALLER check
                has_caller_check = False
                for j in range(max(0, i-10), i):
                    if opcode_names[j] == 'CALLER':
                        has_caller_check = True
                        break
                
                if not has_caller_check:
                    vulns.append(Vulnerability(
                        vuln_type=VulnerabilityType.ACCESS_CONTROL,
                        severity=dangerous_ops[opcode],
                        title=f"Missing Access Control for {opcode}",
                        description=(
                            f"Dangerous operation {opcode} at offset {offset} "
                            "without visible caller authentication. "
                            "This may allow unauthorized users to execute privileged functions."
                        ),
                        location=f"offset_{offset}",
                        confidence=0.65,
                        remediation=(
                            "Implement access control:\n"
                            "require(msg.sender == owner, 'Only owner');\n"
                            "Or use OpenZeppelin's Ownable/AccessControl."
                        ),
                        references=[
                            "https://swcregistry.io/docs/SWC-105",
                            "CWE-284"
                        ],
                        cwe_id="CWE-284",
                    ))
        
        return vulns
    
    def _detect_delegatecall_issues(self, opcodes: List[tuple]) -> List[Vulnerability]:
        """Erkennt DELEGATECALL-spezifische Probleme"""
        vulns = []
        opcode_names = [op[1] for op in opcodes]
        
        for i, (offset, opcode, _) in enumerate(opcodes):
            if opcode == 'DELEGATECALL':
                # Check if target address comes from CALLDATALOAD (user input)
                for j in range(max(0, i-10), i):
                    if opcode_names[j] == 'CALLDATALOAD':
                        vulns.append(Vulnerability(
                            vuln_type=VulnerabilityType.DELEGATECALL,
                            severity=VulnerabilitySeverity.CRITICAL,
                            title="Delegatecall to User-Controlled Address",
                            description=(
                                f"DELEGATECALL at offset {offset} uses user-supplied address. "
                                "This allows arbitrary code execution in the context of this contract."
                            ),
                            location=f"offset_{offset}",
                            confidence=0.8,
                            remediation=(
                                "Never use DELEGATECALL with user-controlled addresses. "
                                "Use a whitelist of allowed implementation contracts."
                            ),
                            references=[
                                "https://swcregistry.io/docs/SWC-112",
                                "CWE-829"
                            ],
                            cwe_id="CWE-829",
                        ))
                        break
        
        return vulns
    
    def _detect_timestamp_issues(self, opcodes: List[tuple]) -> List[Vulnerability]:
        """Erkennt problematische Timestamp-Nutzung"""
        vulns = []
        opcode_names = [op[1] for op in opcodes]
        
        for i, (offset, opcode, _) in enumerate(opcodes):
            if opcode == 'TIMESTAMP':
                # Check if used in modulo or division (randomness)
                for j in range(i+1, min(i+10, len(opcodes))):
                    if opcode_names[j] in ['MOD', 'DIV']:
                        vulns.append(Vulnerability(
                            vuln_type=VulnerabilityType.TIMESTAMP_DEPENDENCE,
                            severity=VulnerabilitySeverity.MEDIUM,
                            title="Timestamp Manipulation Risk",
                            description=(
                                f"Block timestamp at offset {offset} used for {opcode_names[j]} operation. "
                                "Miners can manipulate timestamps within ~15 seconds."
                            ),
                            location=f"offset_{offset}",
                            confidence=0.75,
                            remediation=(
                                "Avoid using block.timestamp for critical logic. "
                                "Use block.number for time-based conditions, or Chainlink VRF for randomness."
                            ),
                            references=[
                                "https://swcregistry.io/docs/SWC-116",
                                "CWE-330"
                            ],
                            cwe_id="CWE-330",
                        ))
                        break
        
        return vulns
    
    def _detect_tx_origin(self, opcodes: List[tuple]) -> List[Vulnerability]:
        """Erkennt tx.origin für Authentication"""
        vulns = []
        opcode_names = [op[1] for op in opcodes]
        
        for i, (offset, opcode, _) in enumerate(opcodes):
            if opcode == 'ORIGIN':
                # Check if used in EQ comparison (authentication)
                for j in range(i+1, min(i+5, len(opcodes))):
                    if opcode_names[j] == 'EQ':
                        vulns.append(Vulnerability(
                            vuln_type=VulnerabilityType.TX_ORIGIN,
                            severity=VulnerabilitySeverity.HIGH,
                            title="tx.origin Used for Authentication",
                            description=(
                                f"tx.origin at offset {offset} used for authorization. "
                                "This is vulnerable to phishing attacks where malicious "
                                "contracts can trick users into executing privileged functions."
                            ),
                            location=f"offset_{offset}",
                            confidence=0.85,
                            remediation=(
                                "Use msg.sender instead of tx.origin:\n"
                                "require(msg.sender == owner);"
                            ),
                            references=[
                                "https://swcregistry.io/docs/SWC-115",
                                "CWE-477"
                            ],
                            cwe_id="CWE-477",
                        ))
                        break
        
        return vulns
    
    def _detect_selfdestruct_issues(self, opcodes: List[tuple]) -> List[Vulnerability]:
        """Erkennt ungeschützte SELFDESTRUCT"""
        # Already covered in _detect_access_control
        return []
    
    def _detect_frontrunning(self, opcodes: List[tuple]) -> List[Vulnerability]:
        """Erkennt Frontrunning-Anfälligkeit"""
        vulns = []
        opcode_names = [op[1] for op in opcodes]
        
        # Check for state changes based on CALLDATALOAD without commit-reveal
        state_changing = False
        uses_calldata = False
        
        for i, (offset, opcode, _) in enumerate(opcodes):
            if opcode == 'CALLDATALOAD':
                uses_calldata = True
            if opcode == 'SSTORE' and uses_calldata:
                state_changing = True
                
                # Simple heuristic: if there's no SHA3 (hashing for commit-reveal)
                has_commit = any(op[1] == 'SHA3' for op in opcodes[max(0,i-20):i])
                
                if not has_commit and i % 15 == 0:  # Report sparsely
                    vulns.append(Vulnerability(
                        vuln_type=VulnerabilityType.FRONTRUNNING,
                        severity=VulnerabilitySeverity.LOW,
                        title="Potential Frontrunning Risk",
                        description=(
                            f"State change at offset {offset} based on user input "
                            "without commit-reveal pattern. May be vulnerable to frontrunning."
                        ),
                        location=f"offset_{offset}",
                        confidence=0.4,
                        remediation=(
                            "Consider implementing commit-reveal scheme for sensitive operations, "
                            "or use Flashbots to prevent MEV."
                        ),
                        references=[
                            "https://consensys.github.io/smart-contract-best-practices/attacks/frontrunning/"
                        ],
                    ))
        
        return vulns
    
    def _detect_gas_issues(self, opcodes: List[tuple]) -> List[Vulnerability]:
        """Erkennt Gas-Limit-DoS-Probleme"""
        vulns = []
        
        # Check for loops with external calls (simplified)
        # In real implementation, would need control flow graph
        
        return vulns  # Simplified for PoC
    
    def _load_patterns(self) -> Dict:
        """Lädt bekannte Vulnerability-Patterns"""
        # In Production: Aus Datenbank oder ML-Modell
        return {}


# Singleton
vulnerability_detector = VulnerabilityDetector()
