"""
Contract Analysis Report Generator
===================================
Generates professional audit reports in PDF and JSON formats.
"""

from typing import Dict
import json
from datetime import datetime


class ReportGenerator:
    """
    Generates audit reports from contract analysis results.
    Supports: PDF, JSON, Markdown
    """
    
    def generate_json_report(
        self,
        analysis: Dict,
        include_metadata: bool = True
    ) -> str:
        """Generate JSON report"""
        report = {
            "report_type": "contract_analysis",
            "format_version": "1.0",
        }
        
        if include_metadata:
            report["metadata"] = {
                "generated_at": datetime.utcnow().isoformat(),
                "tool": "Blockchain Forensics Platform",
                "version": "1.0.0",
            }
        
        report["analysis"] = analysis
        
        return json.dumps(report, indent=2)
    
    def generate_markdown_report(
        self,
        analysis: Dict
    ) -> str:
        """Generate Markdown report"""
        lines = [
            "# Smart Contract Security Audit Report",
            "",
            f"**Contract:** `{analysis.get('address', 'N/A')}`  ",
            f"**Chain:** {analysis.get('chain', 'N/A')}  ",
            f"**Generated:** {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC  ",
            "",
            "---",
            "",
        ]
        
        # Executive Summary
        lines.extend([
            "## Executive Summary",
            "",
            f"**Risk Score:** {analysis.get('score', 0):.2f}/1.0  ",
            f"**Risk Level:** {analysis.get('risk_level', 'unknown').upper()}  ",
            "",
        ])
        
        # Summary
        if "summary" in analysis:
            lines.extend([
                "**Summary:**",
                "",
                "```",
                analysis["summary"],
                "```",
                "",
            ])
        
        # Proxy Information
        proxy = analysis.get("proxy", {})
        if proxy.get("is_proxy"):
            lines.extend([
                "## Proxy Information",
                "",
                f"- **Type:** {proxy.get('type', 'unknown')}  ",
                f"- **Source:** {proxy.get('source', 'unknown')}  ",
                f"- **Implementation:** `{proxy.get('implementation', 'N/A')}`  ",
                "",
            ])
        
        # Vulnerabilities
        vulns = analysis.get("vulnerabilities", {})
        if vulns.get("total", 0) > 0:
            lines.extend([
                "## Vulnerabilities",
                "",
                f"**Total:** {vulns['total']}  ",
                f"- Critical: {vulns.get('critical', 0)}  ",
                f"- High: {vulns.get('high', 0)}  ",
                f"- Medium: {vulns.get('medium', 0)}  ",
                f"- Low: {vulns.get('low', 0)}  ",
                "",
            ])
        
        # Findings
        findings = analysis.get("findings", [])
        if findings:
            lines.extend([
                "## Detailed Findings",
                "",
            ])
            for i, finding in enumerate(findings[:10], 1):
                lines.extend([
                    f"### {i}. {finding.get('kind', 'Unknown')}",
                    "",
                    f"**Severity:** {finding.get('severity', 'unknown').upper()}  ",
                    "**Evidence:**",
                    "",
                    f"> {finding.get('evidence', 'No details available')}",
                    "",
                ])
        
        # Interface
        interface = analysis.get("interface", {})
        if interface:
            lines.extend([
                "## Contract Interface",
                "",
                f"**Standards:** {', '.join(interface.get('standards', []))}  ",
                f"**Functions:** {interface.get('functions_count', 0)}  ",
                f"**Events:** {', '.join(interface.get('events', []))}  ",
                "",
            ])
        
        # Statistics
        stats = analysis.get("statistics", {})
        if stats:
            lines.extend([
                "## Technical Statistics",
                "",
                f"- Total Opcodes: {stats.get('total_opcodes', 0)}  ",
                f"- Unique Opcodes: {stats.get('unique_opcodes', 0)}  ",
                f"- Complexity Score: {stats.get('complexity_score', 0):.2f}  ",
                f"- External Calls: {stats.get('external_calls', 0)}  ",
                f"- Storage Operations: {stats.get('storage_operations', 0)}  ",
                "",
            ])
        
        lines.extend([
            "---",
            "",
            "*Report generated by Blockchain Forensics Platform*  ",
            "*For questions or support: https://blockchain-forensics.com*",
        ])
        
        return "\n".join(lines)
    
    def generate_pdf_report(
        self,
        analysis: Dict
    ) -> bytes:
        """
        Generate PDF report (stub - would use reportlab/weasyprint in production)
        For now, returns markdown as bytes with PDF header
        """
        markdown = self.generate_markdown_report(analysis)
        
        # In production, convert markdown to PDF using weasyprint or similar
        # For now, just add a header
        pdf_stub = f"""PDF REPORT STUB
(In production, this would be a proper PDF using reportlab/weasyprint)

{markdown}
""".encode('utf-8')
        
        return pdf_stub


# Singleton
report_generator = ReportGenerator()
