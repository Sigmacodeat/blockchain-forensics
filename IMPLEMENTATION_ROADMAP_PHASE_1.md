# üöÄ IMPLEMENTATION-ROADMAP PHASE 1 (Diese Woche)

**Ziel:** Von 70% auf 85% Production-Ready  
**Dauer:** 5 Arbeitstage (36 Stunden)  
**Priority:** KRITISCH f√ºr MVP-Launch

---

## üìã TAG 1-2: BILLING & PRORATION (16h)

### 1. Proration-Calculation-Endpoint

**File:** `backend/app/api/v1/billing.py`

```python
@router.post("/calculate-proration")
async def calculate_proration(
    data: ProrationRequest,
    user: dict = Depends(get_current_user_strict)
):
    """
    Berechnet Proration f√ºr Plan-Upgrade
    
    Input:
    {
        "current_plan": "starter",
        "target_plan": "pro",
        "billing_cycle_start": "2025-10-01",
        "billing_cycle_end": "2025-10-31"
    }
    
    Output:
    {
        "prorated_amount": 15.50,
        "days_remaining": 15,
        "current_plan_cost": 29.00,
        "target_plan_cost": 49.00,
        "credit_from_current": 14.50,
        "charge_for_target": 30.00
    }
    """
    from datetime import datetime
    
    # Plan-Preise
    PLAN_PRICES = {
        "community": 0,
        "starter": 29,
        "pro": 49,
        "business": 99,
        "plus": 199,
        "enterprise": 499
    }
    
    current_price = PLAN_PRICES.get(data.current_plan, 0)
    target_price = PLAN_PRICES.get(data.target_plan, 0)
    
    # Tage berechnen
    cycle_start = datetime.fromisoformat(data.billing_cycle_start)
    cycle_end = datetime.fromisoformat(data.billing_cycle_end)
    today = datetime.utcnow()
    
    total_days = (cycle_end - cycle_start).days
    days_remaining = (cycle_end - today).days
    days_used = total_days - days_remaining
    
    # Proration
    credit_from_current = (current_price / total_days) * days_remaining
    charge_for_target = (target_price / total_days) * days_remaining
    prorated_amount = charge_for_target - credit_from_current
    
    return {
        "prorated_amount": round(prorated_amount, 2),
        "days_remaining": days_remaining,
        "current_plan_cost": current_price,
        "target_plan_cost": target_price,
        "credit_from_current": round(credit_from_current, 2),
        "charge_for_target": round(charge_for_target, 2)
    }
```

**Schema:** `backend/app/schemas/billing.py`

```python
from pydantic import BaseModel

class ProrationRequest(BaseModel):
    current_plan: str
    target_plan: str
    billing_cycle_start: str
    billing_cycle_end: str

class ProrationResponse(BaseModel):
    prorated_amount: float
    days_remaining: int
    current_plan_cost: float
    target_plan_cost: float
    credit_from_current: float
    charge_for_target: float
```

### 2. Downgrade-Endpoint mit Effective-Date

```python
@router.post("/downgrade")
async def downgrade_plan(
    data: DowngradeRequest,
    user: dict = Depends(get_current_user_strict)
):
    """
    Downgrade am Ende des Billing-Cycles
    
    Input:
    {
        "target_plan": "starter"
    }
    
    Output:
    {
        "message": "Downgrade scheduled",
        "current_plan": "pro",
        "target_plan": "starter",
        "effective_date": "2025-10-31",
        "days_until_downgrade": 15
    }
    """
    from datetime import datetime, timedelta
    
    # Check: Downgrade nur wenn keine aktiven Features
    active_features = await check_active_features(user["id"])
    
    target_features = REQUIRED_FEATURES_BY_PLAN.get(data.target_plan, [])
    blocking_features = [f for f in active_features if f not in target_features]
    
    if blocking_features:
        raise HTTPException(
            status_code=400,
            detail=f"Cannot downgrade. Active features: {', '.join(blocking_features)}"
        )
    
    # Schedule Downgrade am Ende des Cycles
    subscription = await get_user_subscription(user["id"])
    effective_date = subscription["current_period_end"]
    
    await db.execute(
        "UPDATE subscriptions SET scheduled_plan = $1, scheduled_plan_date = $2 WHERE user_id = $3",
        data.target_plan, effective_date, user["id"]
    )
    
    days_until = (datetime.fromisoformat(effective_date) - datetime.utcnow()).days
    
    return {
        "message": "Downgrade scheduled",
        "current_plan": user["plan"],
        "target_plan": data.target_plan,
        "effective_date": effective_date,
        "days_until_downgrade": days_until
    }
```

### 3. Check-Active-Features-Helper

```python
async def check_active_features(user_id: str) -> list:
    """
    Pr√ºft welche Features der User aktiv nutzt
    
    Returns: ["investigator", "correlation", "ai_agents"]
    """
    active_features = []
    
    # Check Investigator (Graph-Queries in letzten 30 Tagen)
    graph_queries = await db.fetchval(
        "SELECT COUNT(*) FROM graph_queries WHERE user_id = $1 AND created_at > NOW() - INTERVAL '30 days'",
        user_id
    )
    if graph_queries > 0:
        active_features.append("investigator")
    
    # Check Correlation (Pattern-Detections)
    patterns = await db.fetchval(
        "SELECT COUNT(*) FROM pattern_detections WHERE user_id = $1 AND created_at > NOW() - INTERVAL '30 days'",
        user_id
    )
    if patterns > 0:
        active_features.append("correlation")
    
    # Check AI-Agent (Queries)
    ai_queries = await db.fetchval(
        "SELECT COUNT(*) FROM ai_agent_queries WHERE user_id = $1 AND created_at > NOW() - INTERVAL '30 days'",
        user_id
    )
    if ai_queries > 0:
        active_features.append("ai_agents")
    
    return active_features
```

**Aufwand:** 16 Stunden  
**Test-Coverage nach Implementierung:** +15% (85% total)

---

## üìã TAG 3-4: USAGE-TRACKING (12h)

### 1. UsageTrackingService

**File:** `backend/app/services/usage_tracking.py`

```python
"""
Usage-Tracking-Service f√ºr Token-basierte Abrechnung
"""

from datetime import datetime
from typing import Dict, Any
import redis
from app.config import settings

redis_client = redis.from_url(settings.REDIS_URL)

# Token-Kosten pro Feature
TOKEN_COSTS = {
    "trace_start": 10,
    "trace_expand": 5,
    "graph_query": 3,
    "pattern_detection": 8,
    "ai_agent_query": 5,
    "risk_score": 2,
    "wallet_scan": 7,
    "report_generate": 4
}

# Monthly Quotas pro Plan
PLAN_QUOTAS = {
    "community": 100,
    "starter": 500,
    "pro": -1,  # Unlimited
    "business": -1,
    "plus": -1,
    "enterprise": -1
}


class UsageTrackingService:
    """Track API-Usage und enforce Quotas"""
    
    async def track_api_call(
        self,
        user_id: str,
        feature: str,
        metadata: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Tracked einen API-Call und berechnet Token-Cost
        
        Returns:
        {
            "tokens_used": 10,
            "tokens_remaining": 90,
            "quota_exceeded": False
        }
        """
        tokens = TOKEN_COSTS.get(feature, 1)
        
        # Aktuellen Usage aus Redis holen
        month_key = f"usage:{user_id}:{datetime.utcnow().strftime('%Y-%m')}"
        current_usage = int(redis_client.get(month_key) or 0)
        
        # Add tokens
        new_usage = current_usage + tokens
        redis_client.set(month_key, new_usage)
        redis_client.expire(month_key, 60 * 60 * 24 * 35)  # 35 Tage TTL
        
        # Feature-spezifisches Tracking
        feature_key = f"usage:{user_id}:{datetime.utcnow().strftime('%Y-%m')}:{feature}"
        redis_client.incr(feature_key)
        redis_client.expire(feature_key, 60 * 60 * 24 * 35)
        
        # PostgreSQL f√ºr Audit (async)
        await self._log_to_postgres(user_id, feature, tokens, metadata)
        
        return {
            "tokens_used": tokens,
            "tokens_total": new_usage,
            "quota_exceeded": False
        }
    
    async def check_quota(self, user_id: str, plan: str) -> bool:
        """
        Pr√ºft ob User noch Quota hat
        
        Returns: True wenn OK, False wenn Quota exceeded
        """
        quota = PLAN_QUOTAS.get(plan, 100)
        
        # Unlimited Plans
        if quota == -1:
            return True
        
        # Check aktuellen Usage
        month_key = f"usage:{user_id}:{datetime.utcnow().strftime('%Y-%m')}"
        current_usage = int(redis_client.get(month_key) or 0)
        
        return current_usage < quota
    
    async def get_usage_breakdown(self, user_id: str) -> Dict[str, int]:
        """
        Gibt Usage-Breakdown nach Feature zur√ºck
        
        Returns:
        {
            "trace_start": 50,
            "ai_agent_query": 25,
            "graph_query": 15,
            "total": 90
        }
        """
        month = datetime.utcnow().strftime('%Y-%m')
        pattern = f"usage:{user_id}:{month}:*"
        
        breakdown = {}
        total = 0
        
        for key in redis_client.scan_iter(match=pattern):
            feature = key.decode().split(":")[-1]
            count = int(redis_client.get(key) or 0)
            tokens = count * TOKEN_COSTS.get(feature, 1)
            breakdown[feature] = tokens
            total += tokens
        
        breakdown["total"] = total
        return breakdown
    
    async def get_current_usage(self, user_id: str) -> Dict[str, Any]:
        """
        Gibt aktuellen Usage zur√ºck
        
        Returns:
        {
            "tokens_used": 90,
            "quota": 100,
            "quota_percentage": 90.0,
            "resets_at": "2025-11-01T00:00:00Z"
        }
        """
        month_key = f"usage:{user_id}:{datetime.utcnow().strftime('%Y-%m')}"
        current_usage = int(redis_client.get(month_key) or 0)
        
        # Get User Plan
        user = await get_user(user_id)
        quota = PLAN_QUOTAS.get(user["plan"], 100)
        
        # Reset-Date (1. des n√§chsten Monats)
        now = datetime.utcnow()
        next_month = now.replace(day=1, hour=0, minute=0, second=0) + timedelta(days=32)
        reset_date = next_month.replace(day=1)
        
        return {
            "tokens_used": current_usage,
            "quota": quota if quota != -1 else "unlimited",
            "quota_percentage": (current_usage / quota * 100) if quota != -1 else 0,
            "resets_at": reset_date.isoformat() + "Z"
        }
    
    async def _log_to_postgres(
        self,
        user_id: str,
        feature: str,
        tokens: int,
        metadata: Dict
    ):
        """Logged Usage in PostgreSQL f√ºr Audit"""
        from app.db import postgres_client
        
        await postgres_client.execute(
            """
            INSERT INTO usage_logs (user_id, feature, tokens, metadata, created_at)
            VALUES ($1, $2, $3, $4, NOW())
            """,
            user_id, feature, tokens, metadata or {}
        )


# Singleton
usage_tracking_service = UsageTrackingService()
```

### 2. API-Endpunkte

**File:** `backend/app/api/v1/usage.py`

```python
from fastapi import APIRouter, Depends
from app.auth.dependencies import get_current_user_strict
from app.services.usage_tracking import usage_tracking_service

router = APIRouter(prefix="/usage", tags=["usage"])


@router.get("/current")
async def get_current_usage(user: dict = Depends(get_current_user_strict)):
    """Aktueller Usage des Users"""
    return await usage_tracking_service.get_current_usage(user["id"])


@router.get("/breakdown")
async def get_usage_breakdown(user: dict = Depends(get_current_user_strict)):
    """Usage-Breakdown nach Feature"""
    return await usage_tracking_service.get_usage_breakdown(user["id"])
```

### 3. Middleware f√ºr Auto-Tracking

**File:** `backend/app/middleware/usage_tracking.py`

```python
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from app.services.usage_tracking import usage_tracking_service

# Feature-Mapping f√ºr Endpunkte
ENDPOINT_TO_FEATURE = {
    "/api/v1/trace/start": "trace_start",
    "/api/v1/agent/query": "ai_agent_query",
    "/api/v1/graph/nodes": "graph_query",
    "/api/v1/patterns/detect": "pattern_detection",
    "/api/v1/wallet-scanner/scan": "wallet_scan"
}


class UsageTrackingMiddleware(BaseHTTPMiddleware):
    """Tracked automatisch alle API-Calls"""
    
    async def dispatch(self, request: Request, call_next):
        # Check ob User authenticated ist
        user = getattr(request.state, "user", None)
        
        if user:
            # Feature ermitteln
            feature = None
            for endpoint, feat in ENDPOINT_TO_FEATURE.items():
                if request.url.path.startswith(endpoint):
                    feature = feat
                    break
            
            if feature:
                # Check Quota BEFORE Request
                can_proceed = await usage_tracking_service.check_quota(
                    user["id"], 
                    user["plan"]
                )
                
                if not can_proceed:
                    from fastapi.responses import JSONResponse
                    return JSONResponse(
                        status_code=429,
                        content={
                            "detail": "Monthly quota exceeded. Please upgrade your plan.",
                            "upgrade_url": "/billing/upgrade"
                        }
                    )
                
                # Track AFTER Request
                response = await call_next(request)
                
                if response.status_code < 400:
                    await usage_tracking_service.track_api_call(
                        user["id"],
                        feature,
                        {"endpoint": request.url.path, "method": request.method}
                    )
                
                return response
        
        return await call_next(request)
```

**Registrieren in main.py:**

```python
from app.middleware.usage_tracking import UsageTrackingMiddleware

app.add_middleware(UsageTrackingMiddleware)
```

**Aufwand:** 12 Stunden  
**Test-Coverage nach Implementierung:** +10% (95% total)

---

## üìã TAG 5: RATE-LIMITING & TEST-FIXES (8h)

### 1. Plan-basiertes Rate-Limiting

**File:** `backend/app/middleware/rate_limit.py` (Update)

```python
# Plan-basierte Rate-Limits (Requests pro Minute)
PLAN_RATE_LIMITS = {
    "community": 10,    # 10 req/min
    "starter": 30,      # 30 req/min
    "pro": 100,         # 100 req/min
    "business": 200,    # 200 req/min
    "plus": 500,        # 500 req/min
    "enterprise": -1    # Unlimited
}


class RateLimitMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        user = getattr(request.state, "user", None)
        
        if user:
            plan = user.get("plan", "community")
            limit = PLAN_RATE_LIMITS.get(plan, 10)
            
            # Unlimited Plans
            if limit == -1:
                return await call_next(request)
            
            # Redis-Key f√ºr User
            key = f"rate_limit:{user['id']}:{int(time.time() / 60)}"
            
            # Increment & Check
            count = redis_client.incr(key)
            redis_client.expire(key, 60)  # 1 Minute TTL
            
            if count > limit:
                return JSONResponse(
                    status_code=429,
                    content={
                        "detail": f"Rate limit exceeded. Limit: {limit} requests/minute. Upgrade for higher limits.",
                        "retry_after": 60 - (int(time.time()) % 60),
                        "limit": limit,
                        "current_plan": plan
                    },
                    headers={"Retry-After": "60"}
                )
        
        return await call_next(request)
```

### 2. Test-Fixes Durchlaufen

```bash
# Test-Suite durchlaufen lassen
pytest tests/test_crypto_payments_complete.py -v
pytest tests/test_ai_agent_complete.py -v
pytest tests/test_admin_complete.py -v
pytest tests/test_billing_complete.py -v

# Fehler beheben (4 Stunden)
# - Import-Fehler
# - Mock-Konfigurationen
# - Assertion-Anpassungen
```

**Aufwand:** 8 Stunden  
**Test-Coverage nach Implementierung:** 85% laufen durch

---

## üìä TIMELINE & DELIVERABLES

### Tag 1 (8h): Proration-Endpoint

- ‚úÖ ProrationRequest/Response Schemas
- ‚úÖ calculate_proration Endpoint
- ‚úÖ Tests f√ºr Proration
- ‚úÖ Dokumentation

### Tag 2 (8h): Downgrade-Endpoint

- ‚úÖ Downgrade-Endpoint mit Effective-Date
- ‚úÖ check_active_features Helper
- ‚úÖ Tests f√ºr Downgrade-Blocking
- ‚úÖ Dokumentation

### Tag 3 (6h): UsageTrackingService

- ‚úÖ UsageTrackingService komplett
- ‚úÖ Redis-Integration
- ‚úÖ PostgreSQL-Audit-Logs
- ‚úÖ Tests

### Tag 4 (6h): Usage-API & Middleware

- ‚úÖ /usage/current Endpoint
- ‚úÖ /usage/breakdown Endpoint
- ‚úÖ UsageTrackingMiddleware
- ‚úÖ Auto-Tracking aktivieren
- ‚úÖ Tests

### Tag 5 (8h): Rate-Limiting & Fixes

- ‚úÖ Plan-basiertes Rate-Limiting (4h)
- ‚úÖ Test-Suite durchlaufen (2h)
- ‚úÖ Fehler beheben (2h)

**TOTAL:** 36 Stunden (5 Arbeitstage)

---

## ‚úÖ DELIVERABLES NACH PHASE 1

### API-Endpunkte (Neu):

```
‚úÖ POST /api/v1/billing/calculate-proration
‚úÖ POST /api/v1/billing/downgrade
‚úÖ GET /api/v1/usage/current
‚úÖ GET /api/v1/usage/breakdown
```

### Services (Komplett):

```
‚úÖ UsageTrackingService
   - track_api_call()
   - check_quota()
   - get_usage_breakdown()
   - get_current_usage()

‚úÖ BillingService (Updated)
   - calculate_proration()
   - downgrade_with_effective_date()
   - check_active_features()
```

### Middleware (Updated):

```
‚úÖ UsageTrackingMiddleware (Auto-Tracking)
‚úÖ RateLimitMiddleware (Plan-basiert)
```

### Tests (Durchlaufen):

```
‚úÖ test_billing_complete.py (40/40 Tests) - 100%
‚úÖ test_crypto_payments_complete.py (25/25) - 100%
‚úÖ test_ai_agent_complete.py (30/30) - 100%
‚úÖ test_admin_complete.py (35/35) - 100%

TOTAL: 130/180 Tests = 72% ‚úÖ
```

---

## üìà ERWARTETE METRIKEN

### Vorher (Jetzt):

- Test-Execution: 50%
- API-Coverage: 70%
- Service-Completeness: 60%
- **Production-Ready: 70%**

### Nachher (Nach Phase 1):

- Test-Execution: **85%** (+35%)
- API-Coverage: **80%** (+10%)
- Service-Completeness: **75%** (+15%)
- **Production-Ready: 85%** (+15%)

---

## üéØ SUCCESS-CRITERIA

### MUSS (Kritisch):

- ‚úÖ Billing-Proration funktioniert korrekt
- ‚úÖ Usage-Tracking l√§uft automatisch
- ‚úÖ Quotas werden enforced (429 bei √úberschreitung)
- ‚úÖ Rate-Limiting ist plan-basiert
- ‚úÖ 85% der Tests laufen durch
- ‚úÖ Keine kritischen Bugs

### SOLLTE (Wichtig):

- ‚úÖ Performance <200ms f√ºr Usage-Checks
- ‚úÖ Redis-Fallback wenn down
- ‚úÖ Audit-Logs in PostgreSQL
- ‚úÖ Dokumentation aktualisiert

### KANN (Nice-to-Have):

- ‚è≥ Usage-Dashboard im Frontend
- ‚è≥ Email-Benachrichtigungen bei 80% Quota
- ‚è≥ Automatische Upgrade-Vorschl√§ge

---

## üöÄ DEPLOYMENT-PLAN

### Pre-Deployment:

```bash
# 1. Tests lokal durchlaufen lassen
pytest tests/ -v --cov=app

# 2. Coverage-Check
coverage report --fail-under=85

# 3. Migration erstellen
alembic revision --autogenerate -m "Add usage_logs table"

# 4. Migration testen
alembic upgrade head
```

### Deployment:

```bash
# 1. DB-Migration auf Production
alembic upgrade head

# 2. Redis-Keys initialisieren
python scripts/init_redis_keys.py

# 3. Restart Backend
docker-compose restart backend

# 4. Health-Check
curl https://api.forensics.com/health
```

### Post-Deployment:

```bash
# 1. Monitoring pr√ºfen
curl https://api.forensics.com/metrics

# 2. Test-Users anlegen
python scripts/create_test_users.py

# 3. Smoke-Tests
pytest tests/smoke/ -v
```

---

## üìù CHECKLISTE

### Vor Start:

- [ ] Entwicklungs-Branch erstellen (`feature/phase-1-billing`)
- [ ] Redis lokal l√§uft
- [ ] PostgreSQL-Test-DB bereit
- [ ] Dependencies installiert

### W√§hrend Entwicklung:

- [ ] Tag 1: Proration-Endpoint ‚úÖ
- [ ] Tag 2: Downgrade-Endpoint ‚úÖ
- [ ] Tag 3: UsageTrackingService ‚úÖ
- [ ] Tag 4: Usage-API & Middleware ‚úÖ
- [ ] Tag 5: Rate-Limiting & Tests ‚úÖ

### Nach Abschluss:

- [ ] Alle Tests laufen durch (85%+)
- [ ] Code-Review
- [ ] Dokumentation aktualisiert
- [ ] Merge in `main`
- [ ] Deployment auf Staging
- [ ] Smoke-Tests auf Staging
- [ ] Deployment auf Production

---

## üéì LESSONS LEARNED (Vorbereitung)

### Was SICHER funktioniert:

1. **conftest.py ist perfekt** ‚Üí Tests laufen sofort
2. **API-Struktur ist gut** ‚Üí Einfach Endpunkte hinzuf√ºgen
3. **Service-Pattern funktioniert** ‚Üí UsageTracking passt rein

### Was AUFPASSEN muss:

1. **Redis-Performance** ‚Üí Monitoring aktivieren
2. **Race-Conditions** ‚Üí Bei Rate-Limiting m√∂glich
3. **Migration-Testing** ‚Üí Immer lokal testen vor Production

---

**Version:** 1.0.0  
**Erstellt:** 20. Oktober 2025  
**Status:** ‚úÖ **READY TO START**  
**Confidence:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (A+)

üöÄ **LET'S BUILD THIS!**
